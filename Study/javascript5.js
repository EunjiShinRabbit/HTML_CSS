/*
정규표현식: 정규식, 문자열에 포함된 특정 문자 조합을 찾기 위해 사용되는 패턴
- 정규식 만들기 (RegExp 객체) 만드는 방법 2가지
1) /(슬래시)로 감싸는 패턴인 정규식 리터럴을 사용하는 방법
const regexp = /World/;
2) const regexp = new RegExp(”World”);

- 정규식 함수(메소드)
1) exec(): 정규식을 통해 찾고자 하는 문자열 패턴을 찾고 배열을 반환, 무조건 첫번째 매칭 결과만 반환 
대응되는 문자열을 찾지못하면 null 반환, 패턴.exec(검사할문자열)
2) test(): a대응되는 문자열이 있는지 검사하고 있으면 true, 없으면 false, 패턴.test(검사할문자열)

3) match(): 대응되는 문자열을 찾아 배열로 반환하는 String 객체 내장 함수
대응되는 문자열이 없으면 null을 반환, exec와 동일한 기능 수행, 검사할문자열.match(패턴)
4) search(): 대응되는 문자열이 있는지 검사하고, 대응되는 첫번째 문자열의 인덱스를 반환,
대응되는 문자열이 없으면 -1 반환
5) replace(): 대응되는 문자열을 찾아 다른 문자열로 치환하는 String 객체 내장 함수
6) split(): 대응되는 문자열을 찾고, 찾은 문자열을 기준으로 나누어 배열로 반환하는 String 객체 내장 함수

정리!!
("문자열").match(/정규표현식/플래그)	"문자열"에서 "정규표현식"에 매칭되는 항목들을 배열로 반환
("문자열").replace(/정규표현식/, "대체문자열")	"정규표현식"에 매칭되는 항목을 "대체문자열"로 변환
("문자열").split(정규표현식)	"문자열"을 "정규표현식"에 매칭되는 항목으로 쪼개어 배열로 반환

(정규표현식).test("문자열")	"문자열"이 "정규표현식"과 매칭되면 true, 아니면 false반환
(정규표현식).exec("문자열")	match메서드와 유사(단, 무조건 첫번째 매칭 결과만 반환)

- 정규식 주요 패턴 및 사용 예
const regex = /오늘의/;  // 단순 글자 찾기
const regex = /010/g;  // 모두 찾기
const regex = /[0-9]/g; // 모든 숫자 찾기
const regex = /[a-zA-Z]/g;  // 모든 알파벳 대문자/소문자 찾기
const regex = /[^0-9]/g; // 숫자가 아닌 것 모두 찾기

- 정규식 매칭 패턴 (패턴: 의미)
매칭 패턴을 사용하면, 쉽게 문자/숫자/기호를 표현 할 수 있음
1) a-zA-Z: 영어알파벳(-으로 범위 지정)
2) ㄱ-ㅎ가-힣: 한글 문자(-으로 범위 지정)
3) 0-9: 숫자(-으로 범위 지정)
4) .: 모든 문자열(숫자, 한글, 영어, 특수기호, 공백 모두 가능, 단 줄바꿈은 불가능)
5) \d: 숫자
6) \D: 숫자가 아닌 것
7) \w: 영어 알파벳, 숫자, 언더바(언더스코어, _)
8) \W: \w가 아닌 것
9) \s: space 공백
10) \S: space 공백이 아닌 것
11) \특수기호: 특수기호

- 정규 표현식 검색 패턴 (기호: 의미)
검색 패턴들을 이용하면 AND, OR, StartWith, EndWith 등의 다양한 조합을 만들 수 있음
1) |: OR
2) []: 괄호안의 문자들 중 하나
3) [^문자]: 괄호안의 문자를 제외한것
4) ^문자열: 특정 문자열로 시작(괄호가 없음!! 주의 필요)
5) 문자열$: 특정 문자열로 끝남
6) (): 그룹 검색 및 분류(match 메소드에서 그룹별로 묶어줌)
7) (?:패턴): 그룹 검색(분류 X)
8) \b: 단어의 처음/끝
9) \B: 단어의 처음/끝이 아님

- 정규표현식의 갯수(수량) 패턴 (기호: 의미)
특정 패턴이 몇번 반복되는지 필터링 가능
1) ?: 최대 한번(없거나 하나만 있는것) 
2) *: 없거나 있거나(여러개도 가능)
3) +: 최소 한개(하나만 있거나 여러개)
4) {n}: n개
5) {Min,}: 최소 Min개 이상
6) {Min,Max}: 최소 Min개 이상 최대 Max개 이하

- 정규표현식 플래그(동시에 사용 가능) (플래그: 의미)
1) g: Global, 모든 문자 검색(쓰지 않으면 매칭되는 첫번째 문자만 검색됨)
2) i: Ignore Case, 대소문자 구분 안함
3) m: Multi line, 여러행의 문자열에 대해 검색



*/
// 정규식 기본 사용 예
let str = "Hello World! world!";
const re = /World/;
console.log(re.test(str)); // 대응되는 문자열 포함 여부 확인
// console.log(str.test(re)); 는 에러 발생
console.log(str.search(re)); // 해당 문자열 인덱스 반환

// exec(): 인수로 전달된 문자열에서 특정 패턴을 검색하여, 패턴과 일치하는 문자열을 반환
// 만약 패턴과 일치하는 문자열이 없으면 null을 반환
let targetStr = "구르고, 먹고, 커지고. 디저트로 가득한 세상에서 먹보의 드림 배틀! 네 명의 커비가 먹은 딸기의 양으로 겨루는 대전 액션. 구르면서 나아가는 커비는 무대 위의 딸기를 먹으면 점점 크게 변화. 최종적으로 가장 커진 커비가 우승입니다. 컬러풀한 음식을 무대로 산더미 딸기가 있는 골을 목표로 경쟁하거나, 떨어지는 딸기를 서로 빼앗거나, 상대를 날려 딸기를 가로채거나. 여러가지 배틀로 가장 큰 커비를 결정합니다."
let regEx1 = /커비+/;
let regEx2 = /딸기+/;
let result1 = regEx1.exec(targetStr);
console.log(result1);

// test(): 인수로 전달된 문자열에 특정 패턴과 일치하는 문자열이 있는지를 검색
// 만약 패턴과 일치하는 문자열이 있으면 true를, 없으면 false를 반환

// 전화번호 검사하기
let inputphone = "전화번호: 010-2314-8037, 집전화: 031-201-2100"
let regEx3 = /\d{2,3}-\d{3,4}-\d{4}/g; // 뒤에 g 하면 여러개 다 찾아줌
// \d는 숫자(digit)로 시작한다는 뜻, \d{3} 숫자로 시작하고 숫자 3개가 와아햔다는뜻
// \d{2,3} 숫자 2개가 와야한다는 뜻, - 다음에 하이픈이 와야한다는 뜻
// g 매칭되는 항목을 모두 찾음
// let result3 = regEx3.test(inputphone);
let result3 = inputphone.match(regEx3); 
console.log(result3);
for(let e of result3){
  console.log(e);
}

// 이메일 정규식
const regEx4 = /^([a-z]+\d*)+(\.?\w+)+@\w+(\.\w{2,3})+$/;
console.log(regEx4.test("starkirby@gmail.com"));

// 웹사이트 주소 정규식
// http:// 나 https://로 시작하고, 알파벳, 어더스코어(_), 하이픈(-), dot(.)으로 이루어져 있음
const regEx5 = /https?:\/\/[\w\-\.]+/g;